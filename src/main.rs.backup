mod services;
mod models;

use qmetaobject::*;
use cstr::cstr;
use std::path::PathBuf;

#[derive(QObject, Default)]
struct LecternController {
    base: qt_base_class!(trait QObject),
    
    // Properties
    is_processing: qt_property!(bool; NOTIFY is_processing_changed),
    status_message: qt_property!(QString; NOTIFY status_message_changed),
    current_folder: qt_property!(QString; NOTIFY current_folder_changed),
    progress_value: qt_property!(f64; NOTIFY progress_value_changed),
    
    abs_host: qt_property!(QString; NOTIFY abs_host_changed),
    abs_token: qt_property!(QString; NOTIFY abs_token_changed),
    abs_library_id: qt_property!(QString; NOTIFY abs_library_id_changed),
    local_library_path: qt_property!(QString; NOTIFY local_library_path_changed),
    path_template: qt_property!(QString; NOTIFY path_template_changed),
    
    // Signals
    is_processing_changed: qt_signal!(),
    status_message_changed: qt_signal!(),
    current_folder_changed: qt_signal!(),
    progress_value_changed: qt_signal!(),
    abs_host_changed: qt_signal!(),
    abs_token_changed: qt_signal!(),
    abs_library_id_changed: qt_signal!(),
    local_library_path_changed: qt_signal!(),
    path_template_changed: qt_signal!(),
    
    error_occurred: qt_signal!(message: QString),
    log_message: qt_signal!(message: QString),
    metadata_changed: qt_signal!(),
    conversion_completed: qt_signal!(),
    search_results_ready: qt_signal!(results: QVariantList),
    
    // Methods
    set_folder_path: qt_method!(fn(&mut self, path: QString)),
    save_config: qt_method!(fn(&mut self, host: QString, token: QString, library_id: QString, local_path: QString, template: QString)),
    start_conversion: qt_method!(fn(&mut self)),
    search_metadata: qt_method!(fn(&mut self, query: QString, by_asin: bool)),
    apply_search_result: qt_method!(fn(&mut self, book: QVariantMap)),
}

impl LecternController {
    fn set_folder_path(&mut self, path: QString) {
        let path_str = path.to_string();
        self.current_folder = path;
        self.current_folder_changed();
        
        self.status_message = QString::from(format!("üìÇ Loaded folder"));
        self.status_message_changed();
        
        self.log_message(QString::from(format!("Folder loaded: {}", path_str)));
    }
    
    fn save_config(&mut self, host: QString, token: QString, library_id: QString, local_path: QString, template: QString) {
        self.abs_host = host;
        self.abs_token = token;
        self.abs_library_id = library_id;
        self.local_library_path = local_path;
        self.path_template = template;
        
        self.abs_host_changed();
        self.abs_token_changed();
        self.abs_library_id_changed();
        self.local_library_path_changed();
        self.path_template_changed();
        
        self.log_message(QString::from("Configuration saved"));
        self.status_message = QString::from("‚úì Settings saved");
        self.status_message_changed();
    }
    
    fn start_conversion(&mut self) {
        self.is_processing = true;
        self.is_processing_changed();
        
        self.status_message = QString::from("üîÑ Starting conversion...");
        self.status_message_changed();
        
        self.progress_value = 0.1;
        self.progress_value_changed();
        
        self.log_message(QString::from("Starting conversion process..."));
        
        // TODO: Implement actual conversion logic here
        // For now, just simulate completion
        std::thread::spawn(move || {
            std::thread::sleep(std::time::Duration::from_secs(2));
            // You would emit signals here to update the UI
        });
    }
    
    fn search_metadata(&mut self, query: QString, by_asin: bool) {
        let query_str = query.to_string();
        
        self.status_message = QString::from("üîç Searching...");
        self.status_message_changed();
        
        self.log_message(QString::from(format!("Searching for: {}", query_str)));
        
        // Get a pointer to self that can be moved into the thread
        let ptr = self as *mut LecternController;
        
        std::thread::spawn(move || {
            let rt = tokio::runtime::Runtime::new().unwrap();
            match rt.block_on(services::AudioService::search_metadata(&query_str, by_asin)) {
                Ok(results) => {
                    println!("‚úì Search completed: {} results", results.len());
                    
                    // Convert BookMetadata to QVariantList
                    let qml_results: Vec<QVariant> = results.iter().map(|book| {
                        let mut map = QVariantMap::new();
                        map.insert("title".into(), QVariant::from(book.title.clone()));
                        map.insert("authors".into(), QVariant::from(
                            QVariantList::from_iter(book.authors.iter().map(|a| QVariant::from(a.clone())))
                        ));
                        map.insert("image_url".into(), QVariant::from(book.image_url.clone()));
                        map.insert("asin".into(), QVariant::from(book.asin.clone()));
                        
                        if let Some(narrators) = &book.narrator_names {
                            map.insert("narrator_names".into(), QVariant::from(
                                QVariantList::from_iter(narrators.iter().map(|n| QVariant::from(n.clone())))
                            ));
                        }
                        if let Some(series) = &book.series_name {
                            map.insert("series_name".into(), QVariant::from(series.clone()));
                        }
                        if let Some(date) = &book.release_date {
                            map.insert("release_date".into(), QVariant::from(date.clone()));
                        }
                        
                        QVariant::from(map)
                    }).collect();
                    
                    // Emit signal with results
                    unsafe {
                        if !ptr.is_null() {
                            (*ptr).search_results_ready(QVariantList::from_iter(qml_results));
                            (*ptr).status_message = QString::from(format!("‚úì Found {} results", results.len()));
                            (*ptr).status_message_changed();
                        }
                    }
                }
                Err(e) => {
                    println!("‚ùå Search failed: {}", e);
                    unsafe {
                        if !ptr.is_null() {
                            (*ptr).error_occurred(QString::from(format!("Search failed: {}", e)));
                            (*ptr).status_message = QString::from("‚ùå Search failed");
                            (*ptr).status_message_changed();
                        }
                    }
                }
            }
        });
    }
    
    fn apply_search_result(&mut self, book: QVariantMap) {
        // Extract book data and apply it to the current metadata
        if let Some(title) = book.get("title") {
            self.log_message(QString::from(format!("Applied metadata: {}", title.to_qstring().to_string())));
        }
        
        self.status_message = QString::from("‚úì Metadata applied");
        self.status_message_changed();
        self.metadata_changed();
    }
}

fn main() {
    println!("üéµ Starting Lectern...");
    
    // Initialize QML engine
    qml_register_type::<LecternController>(cstr!("Lectern"), 1, 0, cstr!("LecternController"));
    
    let mut engine = QmlEngine::new();
    
    // Create controller instance
    let controller = QObjectBox::new(LecternController::default());
    engine.set_object_property("controller".into(), controller);
    
    // Load QML
    let qml_path = std::env::current_dir()
        .unwrap()
        .join("qml")
        .join("main.qml");
    
    println!("Loading QML from: {:?}", qml_path);
    
    if !qml_path.exists() {
        eprintln!("‚ùå Error: main.qml not found at {:?}", qml_path);
        eprintln!("Make sure the qml/ directory exists in your project root");
        std::process::exit(1);
    }
    
    engine.load_file(qml_path.into());
    
    println!("Starting Qt event loop...");
    engine.exec();
}
